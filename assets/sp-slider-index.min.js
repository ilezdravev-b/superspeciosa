!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define("index", ["exports"], e) : e((t = t || self).index = {}) }(this, function (t) { "use strict"; var i = { ariaLabel: !1, autoplay: !1, autoplaySeconds: 3, carousel: !1, destroy: !1, dotsHorizontal: !0, dotThumbnails: !1, infinite: !1, showDots: !0, offsetWidth: 10, scrollBy: 1, slidesToShow: 2, selectors: { dots: ".js-sp-slider-dots", dot: ".js-sp-slider-dot", slides: ".js-sp-slider-slides", slide: ".js-sp-slider-slide", prevBtn: ".js-sp-slider-prev", nextBtn: ".js-sp-slider-next", autoplayBtn: ".js-sp-slider-autoplay-btn", autoplayBtnText: ".js-sp-slider-autoplay-btn-text" }, responsive: [] }; function o(t, e) { var s; t.slider = e, t.index = 0, t.indexPrev = -1, t.baseSettings = {}, t.settings = {}, t.id = e.fmSlideID, t.content = { offsetLeft: void 0, offsetRight: void 0, prevBtn: void 0, nextBtn: void 0, dots: void 0, slides: void 0 }, t.state = { isScrolling: !1, isMobile: (s = !1, "maxTouchPoints" in navigator ? s = 0 < navigator.maxTouchPoints : "msMaxTouchPoints" in navigator ? s = 0 < navigator.msMaxTouchPoints : (e = window.matchMedia && matchMedia("(pointer:coarse)")) && "(pointer:coarse)" === e.media ? s = !!e.matches : "orientation" in window && (s = !0), s), lessMotion: window.matchMedia("(prefers-reduced-motion: reduce)").matches, scrollingForward: !0 }, t.data = { slidesWidth: void 0, slideWidth: void 0, viewportWidth: window.innerWidth, offsetWidth: 0, dotsToShow: void 0, cloneCount: 0, autoplayTimer: !1, runSlider: !0 }, t.arrays = { allSlides: [], slides: [], activeSlides: [], dots: [], clones: [] } } const n = function () { for (var s = {}, t = 0; t < arguments.length; t++)!function (t) { for (var e in t) t.hasOwnProperty(e) && ("[object Object]" === Object.prototype.toString.call(t[e]) ? s[e] = n(s[e], t[e]) : s[e] = t[e]) }(arguments[t]); return s }; function r(t, e, s) { t.Events.on("initialize.before", a), o(t, e), function (t, e, s) { let i = e || !1, o = {}; const n = t.slider; !i && n.hasAttribute("data-sp-slider") && (i = JSON.parse(n.getAttribute("data-sp-slider"))); o = l(t, i, s), Object.freeze(o), t.baseSettings = o }(t, s, i), a(t) } function a(e) { e.data.viewportWidth = window.innerWidth; const t = e.baseSettings.responsive; var s; t && 0 < t.length ? (s = t.find(t => t.breakpoint >= e.data.viewportWidth), e.settings = s ? l(e, s.settings, e.baseSettings) : e.baseSettings) : e.settings = e.baseSettings } function l(t, e, s) { const i = n(s, e); return i.infinite && t.state.isMobile && (i.infinite = !1), i } var v = { slideshow: "sp-slider", content: { dots: "sp-slider__dots", dot: "sp-slider__dot", dotThumb: "sp-slider__dot--thumb", dotStandard: "sp-slider__dot--standard", dotWrapper: "sp-slider__dot-wrapper", dotCurrent: "current", slides: "sp-slider__slides", slide: "sp-slider__slide", slideAlignStart: "sp-slider__slide--align-start", clone: "sp-slider__clone", offsetLeft: "sp-slider__offset", offsetRight: "sp-slider__offset" }, scroll: { snapNone: "no-scroll-snap", none: "no-scroll", vertical: "scroll-vertical", noTransition: "no-transition" }, state: { active: "active", dotsOverflowing: "sp-slider__dots--overflowing", dotsVisible: "sp-slider__dots--visible", destroyed: "sp-slider__element--destroyed", isScrolling: "sp-slider__slides--scrolling", slideshowActive: "sp-slider--active", slideshowLoaded: "sp-slider--loaded", autoplayPaused: "paused" } }; function d(t) { return document.createElement(t) } function p(t, e, s) { t.setAttribute(e, s) } function f(t, e) { t.removeAttribute(e) } function c(t, e) { const s = t.slider; var i = v.state.slideshowActive; !function (s, i) { const o = v.state.destroyed, t = v.slideshow, e = s.slider; i ? e.classList.add(t) : e.classList.remove(t); for (const r in s.content) { let t = v.content[r], e = s.content[r]; var n = t instanceof Array; if (!(e instanceof Array) && e && (e = [e]), !n && t && (t = [v.content[r]]), e) { if (i) for (const a of e) t && a.classList.add(...t), a.classList.remove(o); if (!i) for (const l of e) t && l.classList.remove(...t), "slides" != r && l.classList.add(o) } } }(t, e), function (t, e) { for (const o of t.arrays.slides) { var s = v.content.slide, i = v.content.slideAlignStart; e && (o.classList.add(s), t.settings.carousel ? o.classList.remove(i) : o.classList.add(i)), e || o.classList.remove(s, i) } }(t, e), e ? s.classList.add(i) : s.classList.remove(i) } function u(t) { !function (e) { var s = e.id; for (const r in e.content) { var i = e.settings.selectors[r]; let t = [...e.slider.querySelectorAll(i)]; var o, n, i = t.length; 1 === i && (e.content[r] = t[0]), 1 < i && (e.content[r] = t); for ([o, n] of t.entries()) !function (t, e, s, i) { let o = e; 0 < i && (o += i); p(t, "id", `fmSlider${function (t) { return t.charAt(0).toUpperCase() + t.slice(1) }(o)}-${s}`), e.includes("Btn") && p(t, "aria-controls", `fmSliderSlides-${s}`) }(n, r, s, o) } }(t), function (e) { var t = e.settings.selectors.slide; let s = [], i = []; s = Array.from(e.slider.querySelectorAll(t)), 0 === s.length && (s = Array.from(e.content.slides.children)); for (let t = 0; t < e.settings.slidesToShow; t++)i.push(s[t]); e.arrays.activeSlides = i, e.arrays.slides = s, e.arrays.allSlides = s }(t), function (t) { const e = t.content.dots, s = t.settings.selectors.dot, i = t.slider.querySelector(s); i && e && (t.arrays.dots = Array.from(e.querySelectorAll(s))) }(t) } var e, s = (function (t) { function e() { var t, i, a, l, s, e, d = window, c = document; function f(t, e) { this.scrollLeft = t, this.scrollTop = e } function o(t) { if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior) return !0; if ("object" == typeof t && "smooth" === t.behavior) return !1; throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.") } function n(t, e) { return "Y" === e ? t.clientHeight + s < t.scrollHeight : "X" === e ? t.clientWidth + s < t.scrollWidth : void 0 } function r(t, e) { e = d.getComputedStyle(t, null)["overflow" + e]; return "auto" === e || "scroll" === e } function u(t) { for (; t !== c.body && !1 === (s = void 0, s = n(e = t, "Y") && r(e, "Y"), e = n(e, "X") && r(e, "X"), s || e);)t = t.parentNode || t.host; var e, s; return t } function v(t) { var e, s = (l() - t.startTime) / i; e = s = 1 < s ? 1 : s, s = .5 * (1 - Math.cos(Math.PI * e)), e = t.startX + (t.x - t.startX) * s, s = t.startY + (t.y - t.startY) * s, t.method.call(t.scrollable, e, s), e === t.x && s === t.y || d.requestAnimationFrame(v.bind(d, t)) } function p(t, e, s) { var i, o, n, r = l(), t = t === c.body ? (o = (i = d).scrollX || d.pageXOffset, n = d.scrollY || d.pageYOffset, a.scroll) : (o = (i = t).scrollLeft, n = t.scrollTop, f); v({ scrollable: i, method: t, startTime: r, startX: o, startY: n, x: e, y: s }) } "scrollBehavior" in c.documentElement.style && !0 !== d.__forceSmoothScrollPolyfill__ || (t = d.HTMLElement || d.Element, i = 468, a = { scroll: d.scroll || d.scrollTo, scrollBy: d.scrollBy, elementScroll: t.prototype.scroll || f, scrollIntoView: t.prototype.scrollIntoView }, l = d.performance && d.performance.now ? d.performance.now.bind(d.performance) : Date.now, e = d.navigator.userAgent, s = new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(e) ? 1 : 0, d.scroll = d.scrollTo = function () { void 0 !== arguments[0] && (!0 !== o(arguments[0]) ? p.call(d, c.body, void 0 !== arguments[0].left ? ~~arguments[0].left : d.scrollX || d.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : d.scrollY || d.pageYOffset) : a.scroll.call(d, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : d.scrollX || d.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : d.scrollY || d.pageYOffset)) }, d.scrollBy = function () { void 0 !== arguments[0] && (o(arguments[0]) ? a.scrollBy.call(d, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : p.call(d, c.body, ~~arguments[0].left + (d.scrollX || d.pageXOffset), ~~arguments[0].top + (d.scrollY || d.pageYOffset))) }, t.prototype.scroll = t.prototype.scrollTo = function () { if (void 0 !== arguments[0]) if (!0 !== o(arguments[0])) { var t = arguments[0].left, e = arguments[0].top; p.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e) } else { if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted"); a.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop) } }, t.prototype.scrollBy = function () { void 0 !== arguments[0] && (!0 !== o(arguments[0]) ? this.scroll({ left: ~~arguments[0].left + this.scrollLeft, top: ~~arguments[0].top + this.scrollTop, behavior: arguments[0].behavior }) : a.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop)) }, t.prototype.scrollIntoView = function () { var t, e, s; !0 !== o(arguments[0]) ? (e = (t = u(this)).getBoundingClientRect(), s = this.getBoundingClientRect(), t !== c.body ? (p.call(this, t, t.scrollLeft + s.left - e.left, t.scrollTop + s.top - e.top), "fixed" !== d.getComputedStyle(t).position && d.scrollBy({ left: e.left, top: e.top, behavior: "smooth" })) : d.scrollBy({ left: s.left, top: s.top, behavior: "smooth" })) : a.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0]) }) } t.exports = { polyfill: e } }(e = { exports: {} }), e.exports).polyfill; function h(t, e) { let s = !1; var i = 1 == t[e], t = t.responsive.find(t => 1 == t.settings[e]); return (i || t) && (s = !0), s } function m(t) { s(), t.Events.emit("build.before", t), function (e) { const t = h(e.baseSettings, "showDots"), s = e.content.dots, i = e.arrays.dots; if (0 == i.length && s && t) { const a = new DocumentFragment; var o = e.arrays.slides.length, n = e.id; for (let t = 0; t < o; t++) { var r = function (t, e, s) { const i = d("div"), o = d("input"), n = d("label"), r = d("span"), a = e.settings.selectors.dot.replace(".", ""); i.classList.add(v.content.dotWrapper), r.textContent = `Go to slide ${t + 1}`, r.classList.add("sr-only"), p(n, "for", `slideDot${s}-${t}`), p(o, "type", "radio"), p(o, "name", `slideDot${s}`), p(o, "data-slide-index", t), o.classList.add(a, v.content.dot, v.content.dotStandard), p(o, "id", `slideDot${s}-${t}`), t == e.index && (o.classList.add(v.content.dotCurrent), o.checked = !0); return e.arrays.dots.push(o), n.append(r), i.append(o), i.append(n), i }(t, e, n); a.append(r) } s.append(a) } }(t), function (t) { const e = h(t.baseSettings, "carousel"), s = t.content; { var i; e && (i = d("div"), t = d("div"), s.offsetLeft = i, s.offsetRight = t, s.slides.prepend(i), s.slides.append(t)) } }(t), function (t) { if (!CSS.supports("scroll-padding-left", "auto")) { var e = v.scroll.snapNone; const s = t.content.dots, i = t.content.slides; i.classList.add(e), s && s.classList.add(e) } }(t), t.Events.emit("build.after", t), t.slider.classList.add(v.state.slideshowLoaded) } function g(t) { if (h(t.baseSettings, "autoplay")) { t.Events.on("build.before", b), t.Events.on("initialize", y); const e = function (t) { const e = t.advanceSlideshow.bind(t), s = t.slider, i = { timer: void 0, interval: void 0, stopped: !1, start() { i.stopped || (i.stop(), i.timer = setInterval(() => { e() }, i.interval)) }, stop() { clearInterval(i.timer) }, initialize(t) { var e = t.settings, e = e.autoplay && !e.destroy && !t.state.lessMotion; this.interval = 1e3 * t.settings.autoplaySeconds, e ? (i.stopped = !1, this.start()) : (i.stopped = !0, this.stop()) } }; return t.EventListeners.on(["mouseenter", "focus", "touchstart"], s, i.stop.bind(this), !0), t.EventListeners.on(["mouseleave", "blur", "touchend"], s, i.start.bind(this), !0), t.EventListeners.on("click", s, function (t, e, s) { const i = t.content.autoplayBtn, o = v.state.autoplayPaused, n = i.querySelector(t.settings.selectors.autoplayBtnText); i && n && s.target === i && (i.classList.toggle(o), i.classList.contains(o) ? (e.stopped = !0, e.stop(), n.textContent = "Start autoplay") : (e.stopped = !1, e.start(), n.textContent = "Stop autoplay")) }.bind(null, t, i), !0), i }(t); return t.Events.on("initialize", e.initialize.bind(e)), e } } function y(t) { var e = t.settings.autoplay, s = t.settings.destroy; const i = t.content.autoplayBtn; t = v.state.destroyed; e && !s ? i && i.classList.remove(t) : i && i.classList.add(t) } function b(t) { const e = t.slider; var s = e.querySelector(t.settings.selectors.autoplayBtn); s && (t.content.autoplayBtn = s) } function w(t, e) { var s = t.state.isScrolling, i = t.settings.destroy, o = e.type; if (!s && !i) switch (o) { case "click": !function (t, e) { let s; const i = t.index, o = t.settings.scrollBy, n = e.target, r = t.content.prevBtn, a = t.content.nextBtn; (n === a || a instanceof Array && a.includes(n)) && (s = i + o, t.Events.emit("goto", t, s)); (n === r || r instanceof Array && r.includes(n)) && (s = i - o, t.Events.emit("goto", t, s)) }(t, e); break; case "change": !async function (t, e) { const s = e.target, i = t.arrays.dots.includes(s); i && (e = parseInt(s.getAttribute("data-slide-index")), t.Events.emit("goto", t, e)) }(t, e) } } function S(t, e) { var s = e.data; let i, o = s.slidesWidth, n = t.offsetLeft; return i = e.settings.carousel ? n - (o - s.slideWidth) / 2 : n, i } function L(t, e) { var s = e.arrays.slides.length, i = e.data.dotsToShow || s; let o, n = function (t, e, s) { let i = !0; i = e < t; 0 === t && e === s - 1 && (i = !0); t === s - 1 && 0 === e && (i = !1); return i }(t, e.indexPrev, s); return i - 1 < t ? (o = t < s - 1 && t < i ? i - 1 : 0, n = !0) : t < 0 ? (o = i - 1, n = !1) : o = t, e.state.scrollingForward = n, o } function E(e) { return e = e || 2e3, new Promise(t => { setTimeout(() => { t() }, e) }) } function x(t) { T(t), function (t) { const e = v.scroll.none, s = t.content.slides, i = t.arrays.clones, o = v.state.destroyed, n = t.data.runSlider; if (!0 === n && t.settings.infinite) { s.classList.add(e); for (const r of i) r.classList.remove(o) } else { s.classList.remove(e); for (const a of i) a.classList.add(o) } }(t) } function T(t) { let e = 0; var s = t.arrays.slides.length, i = function (t, e) { const s = [t[e]]; if (t = t.responsive) for (const i of t) { const o = i.settings; o.hasOwnProperty(e) && s.push(o[e]) } return Math.max(...s) }(t.baseSettings, "slidesToShow"); e = e > s ? s : i + 1, t.data.cloneCount = e } function _(t) { const e = t.arrays.slides; var s = e.length, i = t.data.cloneCount; const o = [v.content.clone]; let n = [], r = []; t.settings.infinite || o.push(v.state.destroyed), function (t) { let e = new MutationObserver(function (t, e) { "childList" === t[0].type && (document.dispatchEvent(window.fmSlideshowRendered), e.disconnect()) }); e.observe(t, { characterData: !1, childList: !0, attributes: !1, subtree: !0 }) }(t.slider); const a = document.createDocumentFragment(), l = document.createDocumentFragment(); for (let t = 0; t < s; t++) { var d = t < i, c = t > s - i - 1; if (p(e[t], "data-slide-index", t), d) { const f = e[t].cloneNode(!0); f.classList.add(...o), a.append(f), r.push(f) } if (c) { const u = e[t].cloneNode(!0); u.classList.add(...o), l.append(u), n.push(u) } } t.arrays.clones = n.concat(r), t.arrays.allSlides = n.concat(e, r), e[0].before(l), e[s - 1].after(a) } function A(t) { if (t.settings.infinite) { const s = t.content.slides, i = v.scroll.noTransition; var e = function (t) { const e = t.index, s = t.arrays.allSlides, i = t.arrays.slides, o = i.length; let n = !1; var r = t.state.scrollingForward, t = o - 1 <= e && !r, r = e <= 0 && r; (r || t) && (r && (n = s[s.indexOf(i[0]) - 1]), t && (n = s[s.indexOf(i[o - 1]) + 1])); return n }(t); e && (s.classList.add(i), t = S(e, t), s.style.transform = `translateX(-${t}px)`, E(10).then(() => { s.classList.remove(i) })) } } function B(t) { t.Events.emit("initialize.before", t), t.Events.emit("initialize", t), t.Events.emit("initialize.after", t) } function I(t) { return t.EventListeners.on("variantUpdate", document, function (t, e) { var s = parseInt(e.detail.index), e = document.getElementById(e.detail.slideshowID), e = e === t.slider; 0 <= s && e && t.Events.emit("goto", t, s) }.bind(null, t)), { customEvent: "variantUpdate" } } function O(t) { var e, s; return { controls: (s = (e = t).slider, e.EventListeners.on("click", s, w.bind(null, e)), void e.EventListeners.on("change", s, w.bind(null, e))), breakpoints: function (t) { var e = t.baseSettings.responsive; const s = []; if (e) for (const i of e) { const o = window.matchMedia(`(max-width:${i.breakpoint}px)`); s.push(`${i.breakpoint}px`), o.addEventListener ? o.addEventListener("change", () => { B(t) }) : o.addListener(() => { B(t) }) } return s }(t), autoplay: g(t), infinite: void (h((e = t).baseSettings, "infinite") && (e.Events.on("build.before", T), e.Events.on("build.before", _), e.Events.on("initialize", x), e.Events.on("goto.before", A))), variant: I(t) } } class $ { constructor(t = {}) { this.Events = t } on(e, s) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++)this.on(e[t], s); else this.Events.hasOwnProperty(e) || (this.Events[e] = []), this.Events[e].push(s) } emit(t, e = {}, s = null) { if (this.Events.hasOwnProperty(t)) for (const i of this.Events[t]) i(e, s) } } class j { constructor(t = {}) { this.callbacks = t } on(e, s, i, o = !1) { "string" == typeof e && (e = [e]); for (let t = 0; t < e.length; t++)s && (this.callbacks[e[t]] = i, s.addEventListener(e[t], this.callbacks[e[t]], o)) } } function W(t) { var e = { root: t.slider, rootMargin: "50% 0%", threshold: .9 }; const s = new IntersectionObserver(async function (t, e) { t.settings.destroy || (function (t, e) { let s = !1; for (const o of t) { var i = o.target; o.isIntersecting || function (t, e) { const s = t.arrays.activeSlides, i = s.indexOf(e); -1 < i && s.splice(i, 1) }(e, i), o.isIntersecting && (function (t, e) { const s = t.arrays.activeSlides, i = -1 == s.indexOf(e), o = t.settings.slidesToShow, n = t.state.scrollingForward; if (i) { var r = s.length - o; if (n ? s.push(e) : s.unshift(e), 0 < r) { if (n) for (let t = 0; t < r; t++)s.splice(t, 1); n || s.splice(o, s.length - 1) } } }(e, i), s = !0) } s }(e, t), async function (t) { { var e; t.state.isScrolling || (-1 < (e = t.arrays.slides.indexOf(t.arrays.activeSlides[0])) && (t.indexPrev = t.index, t.index = L(e, t)), t.Events.emit("update.dots", t)) } }(t), t.Events.emit("slides.activate", t)) }.bind(null, t), e); for (const i of t.arrays.allSlides) s.observe(i) } async function z(t, e) { t.indexPrev = t.index, t.index = L(e, t), t.Events.emit("update.dots", t), t.state.isScrolling = !0, t.Events.emit("goto.before", t), await E(10), await async function (s, i) { if (s) { const r = i.content.slides; var o = i.arrays.dots, n = v.state.isScrolling; let t = S(s, i), e; r.classList.add(n), D(o, !1), i.settings.infinite ? r.style.transform = `translateX(-${t}px)` : (e = i.state.lessMotion ? "instant" : "smooth", r.scroll({ top: 0, left: t, behavior: e })), await E(650), r.classList.remove(n), D(o, !0) } }(t.arrays.slides[t.index], t), await E(15), t.state.isScrolling = !1, t.Events.emit("goto.after", t) } function D(t, e) { if (e) for (const s of t) f(s, "disabled"); if (!e) for (const i of t) i.checked || p(i, "disabled", "true") } function P(t) { const e = t.content.dots; var s, i, o, n, r = v.state.dotsVisible; t.settings.showDots && e ? (s = t.settings.destroy, i = e, o = v.state.dotsVisible, n = v.state.destroyed, s ? i.classList.add(n) : i.classList.add(o), function (t) { var e = t.arrays.dots.length, s = t.arrays.dots, i = v.state.destroyed, o = function (t) { var e = t.arrays.slides.length, s = t.data.dotsToShow; let i = 0; i = parseInt(e - (t.settings.slidesToShow - 1)), e < s && (i = e, t.settings.carousel && i++); (t.settings.infinite || t.settings.dotThumbnails) && (i = e); return i }(t); t.data.dotsToShow = o; for (let t = 0; t < e; t++) { const n = s[t].parentElement; t < o ? n.classList.remove(i) : n.classList.add(i) } }(t), o = e, t = v.state.dotsOverflowing, o.clientWidth < o.scrollWidth ? o.classList.add(t) : o.classList.remove(t)) : e && e.classList.remove(r) } function M(e) { var s = e.index, t = e.arrays.slides.length, i = e.arrays.dots, o = v.content.dotCurrent; if (s < t && 0 <= s) for (let t = 0; t < i.length; t++) { const n = i[t]; t == s && (n.classList.add(o), n.checked = !0, function (t, e) { const s = t.settings.dotsHorizontal, i = t.content.dots, o = t.arrays.dots.length; let n, r, a, l; s && (n = i.clientWidth, r = e.offsetWidth, a = e.parentElement.offsetLeft - (n - r), l = 0); s || (n = i.clientHeight, r = e.offsetHeight, l = e.parentElement.offsetTop - (n - r), a = 0); o * r > n && i.scroll({ left: a, top: l, behavior: "smooth" }) }(e, n)), t != s && (n.classList.remove(o), n.checked = !1) } } function C(e, t) { let s = e.data.runSlider; null !== t && (s = t), e.arrays.activeSlides = []; for (let t = 0; t < e.settings.slidesToShow; t++)e.arrays.activeSlides.push(e.arrays.slides[t]); var i; c(e, s), i = e, t = s, function (t, e) { const s = t.content.slides, i = t.arrays.slides; let o = i.length; var n = t.settings, r = n.slidesToShow, a = n.offsetWidth, l = n.carousel, n = n.infinite; let d; n && (o += t.arrays.clones.length); l && (d = `${a}% repeat(${o}, ${(100 - 2 * a) / r}%) ${a}%`); l || (d = `repeat(${o}, ${100 / r}%`); e ? (s.style.gridTemplateColumns = d, s.style.transform = "initial") : (s.style.removeProperty("transform"), s.style.removeProperty("grid-template-columns")) }(i, t), function (t, e) { var s = t.settings.carousel && e, i = t.settings.offsetWidth, t = [t.content.offsetLeft, t.content.offsetRight], o = v.state.destroyed; for (const n of t) n && s && (n.style.width = `${i}%`, n.classList.remove(o)), n && !s && (n.style.width = "0", n.classList.add(o)) }(i, t), (t = e).data.slidesWidth = t.content.slides.getBoundingClientRect().width, t.data.slideWidth = t.arrays.slides[0].getBoundingClientRect().width, function (t, e) { var s = t.content.slides, t = t.settings.infinite; e && !t && p(s, "tabindex", "0"); e || f(s, "tabindex") }(e, s), function (t, e) { var s = t.slider, i = t.content.slides, o = t.arrays.allSlides, n = o.length, r = t.arrays.slides.length; if (e) { p(s, "role", "region"), p(s, "aria-roledescription", "carousel"); var a = t.settings.ariaLabel || `Slideshow ${t.id}`; p(s, "aria-label", a), t.settings.autoplay ? (f(i, "aria-atomic"), f(i, "aria-live")) : (p(i, "aria-atomic", "false"), p(i, "aria-live", "polite")); for (let t = 0; t < n; t++) { var l = o[t], d = function (t, e, s) { let i, o; var n = t.getAttribute("data-slide-index"); o = n ? parseInt(n) : e, i = t.hasAttribute("data-slide-label") ? (t = t.getAttribute("data-slide-label"), `${t}, ${o + 1} of ${s}`) : `${o + 1} of ${s}`; return i }(l, t, r); p(l, "role", "group"), p(l, "aria-roledescription", "slide"), p(l, "aria-label", d) } } if (!e) { f(s, "role"), f(s, "aria-roledescription"), f(s, "aria-label"), f(i, "aria-live"), f(i, "aria-atomic"); for (const c of o) f(c, "role"), f(c, "aria-roledescription"), f(c, "aria-label") } }(e, s), P(e), e.Events.emit("goto", e, 0) } function X(t) { var e = t.settings.destroy, s = t.arrays.slides.length > t.settings.slidesToShow; t.data.runSlider = !e && s } function k(t) { const e = t.arrays; var s = t.settings.destroy; for (const o of e.allSlides) { var i = -1 < e.activeSlides.indexOf(o) || s; !function (t, e) { var s = function (t = document) { let e = Array.from(t.querySelectorAll('a[href], button, input:not([type="hidden"]), textarea, select, details, [tabindex]:not([tabindex="-1"]), video')); return e.filter(t => !t.hasAttribute("disabled")) }(t), i = v.state.active; if (!e) { for (const n of s) p(n, "tabindex", "-1"), p(n, "aria-hidden", "true"); t.classList.remove(i), p(t, "aria-hidden", "true") } if (e) { for (const r of s) { var o = r.dataset.tabbable; o && "false" == o ? p(r, "tabindex", "-1") : f(r, "tabindex"), f(r, "aria-hidden") } t.classList.add(i), f(t, "aria-hidden") } }(o, i) } } var q = function () { window.fmUniqueID = window.fmUniqueID || 1, window.fmSlideshowInstances = window.fmSlideshowInstances || [], window.fmSlideshowRendered || (window.fmSlideshowRendered = new Event("fmSlideshowRendered")); return class { constructor(t, e) { var s = "string" == typeof (o = t) || o instanceof String ? document.querySelector(o) : "node" == typeof o || "object" == typeof o || o instanceof Object ? o : (console.error(`The passed element was a ${typeof o}, not a string, object, or node.`), !1); if (s) { var i, o, t = (i = this, void 0 !== (o = (t = s).fmSlideID) ? window.fmSlideshowInstances[o] : (window.fmSlideshowInstances[window.fmUniqueID] = i, t.fmSlideID = window.fmUniqueID, window.fmUniqueID++, !1)); if (t) return t; this.EventListeners = new j, this.Events = new $, r(this, s, e), this.components = O(this), u(this), m(this), async function (t) { document.dispatchEvent(window.fmSlideshowRendered), t.Events.on("update.dots", M), t.Events.on("initialize.before", X), t.Events.on("initialize", C), t.Events.on(["initialize", "slides.activate"], k), t.Events.on("goto", z), W(t), t.Events.emit("initialize.before", t), t.Events.emit("initialize", t), t.Events.emit("initialize.after", t) }(this) } } advanceSlideshow() { this.Events.emit("goto", this, this.index + 1) } goTo(t) { this.Events.emit("goto", this, t) } initialize() { this.Events.emit("initialize", this) } destroy() { this.Events.emit("initialize", this, !1) } } }(); t.FmSlider = q, Object.defineProperty(t, "__esModule", { value: !0 }) });